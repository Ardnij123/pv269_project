#!/bin/python3.11

import argparse
import matplotlib.pyplot as plt
import matplotlib as mplot
import numpy as np

import tkinter as tk
from tkinter import ttk


HELP="""
This script counts events (matches) in bedpe-file generated by ModDotPlot
and creates a heatmap from them with specified window sizes.

Heatmaps are always even-spaced, the window size is even over heatmap.
"""

parser = argparse.ArgumentParser(
	prog='event-counter',
	description=HELP,
)

parser.add_argument('bedpe_file', help='Bedpe file from ModDotPlot')
parser.add_argument('-n', '--window-count', type=int, help=
'''Generate <windows> windows, overwrites window-size setting
Default: 20''')
parser.add_argument('-w', '--window-size', type=int, help=
'''Generate windows of size <window-size>''')
parser.add_argument('-s', '--seq-names', type=str, help=
'''Use lines in file <seq-names> instead of numbers as labels''')

args = parser.parse_args()

bedpe = args.bedpe_file
w_size = 1000


def bedpe_parser(bedpe: str, window_size: int = 1):
    with open(bedpe, 'r') as f:
        for line in f:
            if line[0] == '#':
                continue
            line = line.split("\t")
            yield (int(line[1])-1)//window_size, \
                    (int(line[2])-1)//window_size, \
                    (int(line[4])-1)//window_size, \
                    (int(line[5])-1)//window_size


if bool(args.window_count) + bool(args.window_size) + bool(args.seq_names) > 1:
    print("At most one of window count, size and sequences may be specified")
    exit(1)


# Compute window size
if args.window_size:
    w_size = args.window_size
elif args.seq_names:
    with open(args.seq_names, 'r') as f:
        args.window_count = len(list(filter(lambda x: x, f.read().split("\n"))))

if args.window_count:
    max_idx = max(map(max, bedpe_parser(bedpe))) + 1
    w_size = max_idx // args.window_count + 1
print("WSize: ", w_size)


# Create heatmap
heatdict = dict()

for i, j, k, l in bedpe_parser(bedpe, w_size):
    for s in range(i, j+1):
        for e in range(k, l+1):
            heatdict[(s, e)] = heatdict.get((s, e), 0) + 1

max_window = max(map(max, heatdict))
heatmap = [[0 for _ in range(max_window + 1)] for _ in range(max_window + 1)]
for i in range(max_window + 1):
    for j in range(max_window + 1):
        heatmap[i][j] = max(heatdict.get((i, j), 0), heatdict.get((j, i), 0))
heatmap = np.array(heatmap, dtype=int) + 1

labels = list(map(str, range(1, max_window + 2)))
if len(heatmap) == 23:
    labels = list(map(lambda x: f"chr{x}", range(1, 23)))+['chrX', 'chrY']
if args.seq_names:
    with open(args.seq_names, 'r') as f:
        labels = f.read().split("\n")
        labels = list(filter(lambda x: x, labels))


# Create plot using mathplotlib
fig, axs = plt.subplots(1, 1)
fig = plt.imshow(heatmap, cmap='hot', interpolation='nearest', norm=mplot.colors.LogNorm(vmin=heatmap.min(), vmax=heatmap.max()))
plt.gca().invert_yaxis()
axs.set_xticks(range(len(heatmap)))
axs.set_yticks(range(len(heatmap)))

axs.set_xticklabels(labels, rotation=90)
axs.set_yticklabels(labels)

plt.show(block=False)


def get(array, idxs):
    return [array[i] for i in idxs]

def replot(indices):
    idxs = [labels.index(ind) for ind, var in indices.items() if var.get()]
    axs.cla()
    data = heatmap[idxs, :][:, idxs]
    axs.imshow(data, cmap='hot', interpolation='nearest', norm=mplot.colors.LogNorm(vmin=data.min(), vmax=data.max()))
    axs.set_xticks(range(len(idxs)), get(labels, idxs))
    axs.set_yticks(range(len(idxs)), get(labels, idxs))
    axs.set_xticklabels(get(labels, idxs), rotation=90)
    axs.invert_yaxis()
    plt.draw()


# Interactive matplotlib plot
MAX_ROWS = 20

root = tk.Tk()

col = 0
row = 0
varray = dict([(label, tk.IntVar(root, value=1)) for label in labels])
for label in labels:
    checkbox = ttk.Checkbutton(root, text=label, variable=varray[label])
    checkbox.grid(column=col, row=row)
    row += 1
    if row >= MAX_ROWS:
        row = 0
        col += 1

submit = ttk.Button(root, text="Plot", command=lambda: replot(varray))
submit.grid(column=col, row=MAX_ROWS)

root.mainloop()
